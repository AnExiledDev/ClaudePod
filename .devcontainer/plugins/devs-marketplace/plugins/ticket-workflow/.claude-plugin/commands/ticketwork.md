---
description: Retrieve ticket, create technical implementation plan, post to GitHub issue
argument-hint: [ticket-number]
disable-model-invocation: true
allowed-tools: Bash(gh:*), Bash(git:*), Read, Grep, Glob, AskUserQuestion
---

# /ticket:work - Implementation Planning

Retrieve ticket, convert business requirements to technical plan, post to issue.

## Input

`$ARGUMENTS` - Ticket identifier (e.g., `#123`, `123`, or issue URL)

## Process

### Phase 1: Retrieve and Parse Ticket

```bash
gh issue view $1 --json number,title,body,labels,comments
```

Parse ticket structure:
- Original Request (if present)
- Overview
- Requirements (by system/component)
- Technical Questions
- Acceptance Criteria

Track ticket number in context for subsequent commands.

### Phase 2: Launch Plan Subagent

Use Plan subagent to:

1. **Explore Codebase**
   - Find related code/patterns
   - Identify existing abstractions to use
   - Map dependencies
   - Discover project structure and conventions

2. **Resolve Technical Questions**
   - Explore codebase first
   - Only ask user if ambiguity persists after exploration
   - Document all decisions

3. **Convert Requirements to Technical Spec**

   For each EARS requirement, specify:
   - Files to modify/create
   - Components/classes affected
   - Dependencies required
   - Tests to write (if applicable - see Phase 3)

4. **Build Implementation Plan**

   Structure as phases:
   ```markdown
   ## Technical Plan

   ### Prerequisites
   - [ ] [Dependencies, setup, migrations needed]

   ### Phase 1: [Descriptive Name]
   **Requirements Addressed**: [REQ-1, REQ-2]

   Files:
   - `path/to/file.ext` - [What changes]

   Implementation:
   1. [Step with detail]
   2. [Step with detail]

   Tests: (if applicable)
   - `test_file.ext::test_name` - [What it verifies]

   ### Phase 2: [Descriptive Name]
   ...

   ### Verification Checklist
   - [ ] [Acceptance criteria mapped to verification method]
   ```

### Phase 3: User Review and Test Preference

1. Present full plan to user
2. Get explicit approval before proceeding

**Test Preference** - Before finalizing plan, confirm testing approach:

Use AskUserQuestion to ask:
- What test coverage does the user want? (full, minimal, none)
- Are there existing test patterns to follow?
- Any specific scenarios that MUST be tested?

If user says "no tests" or "skip tests":
- Respect this and exclude test tasks from plan
- Note in plan: "Tests: Skipped per user preference"

If user wants tests:
- Follow testing_standards from system prompt
- Propose specific scenarios, not vague coverage
- Estimate count: "2-3 unit tests for validation, 1 integration test"

3. Allow modifications to plan

### Phase 4: Post to GitHub Issue

Create single batched comment:

```markdown
## Implementation Plan

[Technical plan from above]

## Decisions Made

| Decision | Rationale |
|----------|-----------|
| [Choice] | [Why] |

## Resolved Questions

- **Q**: [Original question from ticket]
  **A**: [Resolution and rationale]

## Test Approach

[Full / Minimal / Skipped] - [Brief rationale]
[If applicable: specific test scenarios planned]

## Assumptions

[NONE without express user approval - list any that were approved]

---
*Plan generated by Claude. Implementation tracked in subsequent commits.*
```

Post via:
```bash
gh issue comment $TICKET --body "$(cat <<'EOF'
[plan content]
EOF
)"
```

## Rules

- **Use Plan subagent** for all exploration and plan generation
- **NEVER defer** without EXPRESS user approval
- **NEVER mark out-of-scope** without EXPRESS user approval
- **All decisions** → documented in issue comment
- **All resolved questions** → documented in issue comment
- **No assumptions** without user approval
- **Track ticket** in context for `/ticket:review-commit` and `/ticket:create-pr`
- **Respect test preferences** - if user says no tests, don't add them

## Context Tracking

After successful planning, maintain in context:
- Current ticket number
- Ticket title
- Key requirements (for commit/PR reference)
- Test preference (full/minimal/none)

Support multiple tickets per session - each `/ticket:work` adds to tracked tickets.

## Example Plan Comment

```markdown
## Implementation Plan

### Prerequisites
- [ ] None required

### Phase 1: Data Layer - Status Field
**Requirements Addressed**: API REQ-1, REQ-2

Files:
- `src/models/character.py` - Add `is_enabled` field with default True
- `src/repositories/character_repo.py` - Update queries to handle enabled filter
- `src/services/character_service.py` - Add toggle method, publish event

Implementation:
1. Add `is_enabled: bool = True` to Character model
2. Generate migration for new column
3. Update repository with optional enabled filter
4. Add `toggle_enabled()` service method with event publishing

Tests:
- `tests/test_character_service.py::test_toggle_enabled_publishes_event`
- `tests/test_character_service.py::test_toggle_updates_database`

### Phase 2: Bot Integration - Proxy Check
**Requirements Addressed**: Bot REQ-1, REQ-2

Files:
- `src/bot/proxy_handler.py` - Check enabled before proxying

Implementation:
1. Update `should_proxy()` to check `character.is_enabled`
2. Return early if disabled (no proxy, no error)

Tests:
- `tests/test_proxy_handler.py::test_disabled_character_not_proxied`

### Phase 3: Dashboard - Toggle UI
**Requirements Addressed**: Dashboard REQ-1, REQ-2

Files:
- `src/components/CharacterCard.tsx` - Add toggle switch
- `src/api/characters.ts` - Add toggle endpoint call

Implementation:
1. Add Switch component to character card header
2. Implement optimistic update with error rollback

Tests: Manual verification (UI component)

### Verification Checklist
- [ ] Migration runs successfully
- [ ] Disabled character not proxied
- [ ] Toggle persists after restart
- [ ] Dashboard shows correct status
- [ ] Event published on toggle

## Decisions Made

| Decision | Rationale |
|----------|-----------|
| Default `is_enabled=True` | Existing characters should continue working |
| Keep in autocomplete | Disabled ≠ hidden, user may want to re-enable |
| Optimistic UI update | Better UX, rollback handles errors |

## Resolved Questions

- **Q**: Should disabled characters appear differently in autocomplete?
  **A**: Yes - show with "(disabled)" suffix, keep selectable for re-enabling.

- **Q**: Default enabled status for new characters?
  **A**: True - matches user expectation that created characters work immediately.

## Test Approach

Minimal - Unit tests for service logic, manual verification for UI.
- 3 unit tests for toggle/proxy behavior
- Manual test for dashboard toggle

## Assumptions

None - all decisions confirmed with user.

---
*Plan generated by Claude. Implementation tracked in subsequent commits.*
```
